

>结构也是一些值的集合，这些值称为它的成员(member)，但一个结构的各个成员可能具有不同的类型。


创建一个名为c的变量，包含了三种类型的成员。
```c
struct SIMAPLE{
    int a;
    char b;
    float c;
} x;

```
``SIMAPLE``是结构标签，我们可以使用结构标签来声明对象。

```c
struct SIMPLE x;
struct SIMPLE y[20];
```
使用``typedef``来创建新的类型。这样我们可以使用类型名而不是结构标签来声明对象。
```c
typedef struct {
    int a;
    char b;
    float c;
} Simple;
```
声明方式如下,可以少写个关键字:
```c
Simple x;
Simple y[20],*z;
```




## .
点操作
结构变量的成员是通过点操作符(.)访问的。点操作符接受两个操作数，左操作数就是结构变量的名字，右操作数就是需要访问的成员的名字。

如果要访问COMPLEX中的 sp变量就可以通过点操作符。
```c

struct COMPLEX
{
    float f;
    int a[20];
    long *lp;
    struct SIMPLE s;
    struct SIMPLE *sp;
    struct SIMPLE sa[10];
    
};



```

```c
struct COMPLEX complex;

(complex.s).a;
(conplex.sa)[1];
```

## ->
和点操作符一样，箭头操作符接受两个操作数，但左操作数必须是一个指向结构的指针。箭头操作符对左操作数执行间接访问取得指针所指向的结构，然后和点操作符一样，根据右操作数选择一个指定的结构成员。但是，间接访问操作内建于箭头操作符中，所以我们不需要显式地执行间接访问或使用括号。

```c
(*cp).f
```
可以写成
```c
cp->f
```

### 不完整的声明

```c
struct B;
struct A{
    struct B *partner;
    ...;
}
struct B{
    struct A *partner;
    ...;
}
```
在A的成员列表中需要标签B的不完整的声明。一旦A被声明之后，B的成员列表也可以被声明。


### 结构体的初始化

下面代码定义、声明并初始化了一个结构体。
```c
struct INIT_EX
{
    int a;
    short b[10];
    SIMPLE c;
} x = {
    10,
    {1, 2, 3, 4, 5},
    {25, 'x', 1.9}
};
```
### 结构的存储分配

## 位段

“位段的声明和结构类似，但它的成员是一个或多个位的字段。这些不同长度的字段实际上存储于一个或多个整型变量中。

位段的声明和任何普通的结构成员声明相同，但有两个例外。首先，位段成员必须声明为int、signed int或unsigned int类型。其次，在成员名的后面是一个冒号和一个整数，这个整数指定该位段所占用的位的数目。”

## 联合
联合的所有成员引用的是内存中相同的位置。当你在不同时刻把不同的东西存储于同一个位置时，就可以使用联合。
```c
union {
    float f;
    int i;
} fi;

```
上面这个例子在32位机子上，fi只占内存中一个32位的字。
```c
fi.f = 3.14159;
printf("%d \n",fi.i);
```
如果成员f被使用，这个字就作为浮点值访问；如果成员i被使用，这个字就作为整型值访问。

例如:定义了一个类型里面包含三种数据类型，但是每次只使用其中一个。这时就适合使用联合了。

### 联合的初始化
```c
union{
    int a;
    float b;
    char c[4];
}x = {5};
```



